import React, { useState, useRef, useEffect, Suspense } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from './ui/card';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from './ui/dialog';
import { Checkbox } from './ui/checkbox';
import { Textarea } from './ui/textarea';
import { 
  PartyPopper, 
  ArrowRight,
  ArrowLeft
} from 'lucide-react';
import { ImageWithFallback } from './figma/ImageWithFallback';
import imageplaceholder from 'figma:asset/ecdfd66b885286c4c43bb92244a555fc7427404e.png';
import { iconIndex } from './icon-index';
import { Star } from 'react-bootstrap-icons';
import { useLoading } from './GlobalLoading'; // Importar useLoading

const videoplaceholder = "https://images.unsplash.com/photo-1642726197561-ef7224c054a6?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHx2aWRlbyUyMHBsYXllciUyMHRodW1ibmFpbHxlbnwxfHx8fDE3NTc3NjA2Nzl8MA&ixlib=rb-4.1.0&q=80&w=1080&utm_source=figma&utm_medium=referral";

interface WireframeElement {
  id: string;
  type: 'rectangle' | 'circle' | 'button' | 'text' | 'line' | 'image' | 'video' | 'icon';
  x: number;
  y: number;
  width: number;
  height: number;
  text?: string;
  backgroundColor?: string;
  textLevel?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p';
  textColor?: string;
  textAlign?: 'left' | 'center' | 'right';
  zIndex?: number;
  borderWidth?: number;
  borderColor?: string;
  borderTopLeftRadius?: number;
  borderTopRightRadius?: number;
  borderBottomLeftRadius?: number;
  borderBottomRightRadius?: number;
  iconName?: string;
  iconComponent?: string;
  imageSrc?: string;
  videoSrc?: string;
  navigationTarget?: string | '__FINISH_TEST__';
  parentId?: string;
  name?: string;
  opacity?: number; // Adicionado para controlar a transparência da imagem
  // Advanced text properties
  fontWeight?: 'normal' | 'bold';
  fontFamily?: 'inter' | 'roboto' | 'arial' | 'helvetica' | 'times' | 'georgia' | 'monospace';
  fontStyle?: 'normal' | 'italic';
  textDecoration?: 'none' | 'underline' | 'line-through';
}

interface Wireframe {
  id: string;
  name: string;
  elements: WireframeElement[];
}

interface Project {
  id: string;
  name: string;
  resolution: 'mobile' | 'tablet' | 'desktop';
  wireframes: Wireframe[];
  createdAt: string;
}

interface Hotspot {
  id: string;
  wireframeId: string;
  x: number;
  y: number;
  width: number;
  height: number;
  targetWireframeId: string | '__FINISH_TEST__';
  isAutoGenerated?: boolean;
  elementId?: string;
}

interface Test {
  id: string;
  projectId?: string;
  name: string;
  objective?: string; // Added objective field
  hotspots?: Hotspot[];
  flows?: any[];
  type: 'wireframe' | 'mapa_calor' | 'pesquisa';
  perguntas?: any[]; // for surveys
  descricao?: string; // for surveys
}

interface Click {
  x: number;
  y: number;
  wireframeId: string;
  timestamp: string;
  correct: boolean;
}

interface TestSession {
  id: string;
  testId: string;
  userName: string;
  userEmail: string;
  clicks: Click[];
  answers?: { [questionId: string]: any };
  startTime: string;
  endTime?: string;
  completed: boolean;
  duration?: number; // Added duration
  clicksPerWireframe?: { [wireframeId: string]: number }; // Added clicks per wireframe
  correctClicks?: number; // Added correct clicks
  incorrectClicks?: number; // Added incorrect clicks
  idleTime?: number; // Added idle time
}

interface UserTestInterfaceProps {
  test: Test;
  project?: Project | null;
  onFinishTest: (session: TestSession) => void;
  onCancel: () => void;
  isDemoMode?: boolean;
}

type TestPhase = 'intro' | 'consent' | 'testing' | 'disqualified';

const getFontSize = (element: WireframeElement, resolution: 'mobile' | 'tablet' | 'desktop') => {
  const fontSizes = {
    desktop: {
      h1: 40,  // 2.5rem
      h2: 32,  // 2rem
      h3: 28,  // 1.75rem
      h4: 24,  // 1.5rem
      h5: 20,  // 1.25rem
      h6: 16,  // 1rem
      p: 16    // 1rem
    },
    tablet: {
      h1: 32,  // 2rem
      h2: 28,  // 1.75rem
      h3: 24,  // 1.5rem
      h4: 20,  // 1.25rem
      h5: 18,  // 1.125rem
      h6: 16,  // 1rem
      p: 15    // 0.95rem
    },
    mobile: {
      h1: 28,  // 1.75rem
      h2: 24,  // 1.5rem
      h3: 20,  // 1.25rem
      h4: 18,  // 1.125rem
      h5: 16,  // 1rem
      h6: 14,  // 0.875rem
      p: 14    // 0.875rem
    }
  };

  const level = element.textLevel || 'p';
  return fontSizes[resolution][level] || fontSizes[resolution].p;
};


export function UserTestInterface({ test, project, onFinishTest, onCancel, isDemoMode = false }: UserTestInterfaceProps) {
  const [phase, setPhase] = useState<TestPhase>('intro');
  const [userName, setUserName] = useState('');
  const [userEmail, setUserEmail] = useState('');
  const [userPhone, setUserPhone] = useState('');
  const [consentAccepted, setConsentAccepted] = useState(false);
  const [currentWireframeId, setCurrentWireframeId] = useState(project?.wireframes?.[0]?.id || '');
  const [clicks, setClicks] = useState<Click[]>([]);
  const [startTime] = useState(new Date().toISOString());
  const [isCompleted, setIsCompleted] = useState(false);
  const [answers, setAnswers] = useState<{ [questionId: string]: any }>({});
  const { showLoading, hideLoading } = useLoading(); // Usar o hook de loading

  const canvasRef = useRef<HTMLDivElement>(null);
  const zoom = 1;

  const handleAnswerChange = (questionId: string, answer: any) => {
    setAnswers(prev => ({ ...prev, [questionId]: answer }));
  };

  const handleSimNaoChange = (question: any, answer: 'sim' | 'nao') => {
    // Assuming 'eliminatoria' and 'resposta_esperada' fields exist in the question object
    if (question.eliminatoria && answer !== question.resposta_esperada) {
      setPhase('disqualified');
    } else {
      handleAnswerChange(question.id, answer);
    }
  };

  const handleMultiChoiceChange = (questionId: string, optionId: string, checked: boolean) => {
    const currentAnswers = answers[questionId] || [];
    if (checked) {
      handleAnswerChange(questionId, [...currentAnswers, optionId]);
    } else {
      handleAnswerChange(questionId, currentAnswers.filter((id: string) => id !== optionId));
    }
  };

  const handleCompleteSurvey = () => {
    const session: TestSession = {
      id: uuidv4(),
      testId: test.id,
      userName: userName.trim(),
      userEmail: userEmail.trim(),
      clicks: [],
      answers: answers,
      startTime: startTime,
      endTime: new Date().toISOString(),
      completed: true
    };
    onFinishTest(session);
  };



  if (phase === 'testing' && test.type === 'pesquisa') {
    const questions = test.perguntas || [];

    return (
      <div className="min-h-screen bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
        <div className="max-w-3xl mx-auto">
          <Card className="bg-white shadow-lg rounded-lg">
            <CardHeader className="text-center p-8 border-b">
              <CardTitle className="text-3xl font-bold text-gray-800">{test.name}</CardTitle>
              <CardDescription className="mt-2 text-lg text-gray-600">{test.descricao}</CardDescription>
            </CardHeader>
            <CardContent className="p-8 space-y-10">
              {questions.length > 0 ? (
                questions.map((question, index) => (
                  <div key={question.id} className="border-t pt-6">
                    <Label className="text-xl font-semibold text-gray-700">Questão {index + 1}</Label>
                    <p className="text-lg mt-2 mb-6 text-gray-800">{question.texto}</p>
                    <div className="space-y-4">
                      {question.tipo === 'aberta' && (
                        <Textarea
                          placeholder="Sua resposta..."
                          className="min-h-[120px] text-base"
                          value={answers[question.id] || ''}
                          onChange={(e) => handleAnswerChange(question.id, e.target.value)}
                        />
                      )}
                      {question.tipo === 'fechada' && question.options?.map((option: any) => (
                        <div key={option.id} className="flex items-center space-x-3 p-3 rounded-md bg-gray-50 hover:bg-gray-100 transition-colors">
                          <Checkbox
                            id={`option-${option.id}`}
                            checked={answers[question.id]?.includes(option.id) || false}
                            onCheckedChange={(checked) => handleMultiChoiceChange(question.id, option.id, !!checked)}
                          />
                          <Label htmlFor={`option-${option.id}`} className="text-base text-gray-700 cursor-pointer">{option.texto}</Label>
                        </div>
                      ))}
                      {question.tipo === 'sim_nao' && (
                        <div className="flex space-x-4">
                          <Button 
                            variant={answers[question.id] === 'sim' ? 'default' : 'outline'}
                            onClick={() => handleSimNaoChange(question, 'sim')}
                            className="flex-1 text-lg py-6"
                          >
                            Sim
                          </Button>
                          <Button 
                            variant={answers[question.id] === 'nao' ? 'destructive' : 'outline'}
                            onClick={() => handleSimNaoChange(question, 'nao')}
                            className="flex-1 text-lg py-6"
                          >
                            Não
                          </Button>
                        </div>
                      )}
                    </div>
                  </div>
                ))
              ) : (
                <div className="text-center py-12">
                  <p className="text-muted-foreground mb-4">Desculpe, esta pesquisa ainda não possui perguntas.</p>
                  <Button onClick={onCancel} variant="outline">Voltar</Button>
                </div>
              )}
              <div className="flex justify-end mt-12 border-t pt-8">
                <Button onClick={handleCompleteSurvey} size="lg" className="text-xl py-7 px-10">Finalizar Pesquisa</Button>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    );
  }

  if (test.type !== 'pesquisa' && !project) {
    return (
        <div className="min-h-screen flex items-center justify-center">
            <div>
                <h1 className="text-2xl font-bold">Erro</h1>
                <p className="text-muted-foreground">
                    Ocorreu um erro ao carregar os dados do teste. Por favor, tente novamente mais tarde.
                </p>
            </div>
        </div>
    )
  }

  const getCanvasDimensions = () => {
    if (!project) return { width: 0, height: 0 };
    switch (project.resolution) {
      case 'mobile': return { width: 375, height: 812 };
      case 'tablet': return { width: 768, height: 1024 };
      case 'desktop': return { width: 1440, height: 900 };
      default: return { width: 375, height: 812 };
    }
  };

  const currentWireframe = project?.wireframes?.find(w => w.id === currentWireframeId);
  const navigableElements = currentWireframe?.elements.filter(e => e.navigationTarget) || [];

  const handleStartTest = () => {
    if (!userName.trim() || !userEmail.trim()) return;
    setPhase('consent');
  };

  const handleAcceptConsent = () => {
    if (!consentAccepted) return;
    setPhase('testing');
  };

  const handleElementClick = (element: WireframeElement, e: React.MouseEvent) => {
    console.log('[UserTestInterface] Element clicked:', element.id, 'Type:', element.type, 'Navigation Target:', element.navigationTarget);
    console.log('[UserTestInterface] Current Phase:', phase);
    if (phase !== 'testing') {
      console.log('[UserTestInterface] Click ignored: Not in testing phase.');
      return;
    }
    e.stopPropagation();

    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) return;

    const x = (e.clientX - rect.left) / zoom;
    const y = (e.clientY - rect.top) / zoom;

    const newClick: Click = {
      x,
      y,
      wireframeId: currentWireframeId,
      timestamp: new Date().toISOString(),
      correct: !!element.navigationTarget
    };

    setClicks(prev => [...prev, newClick]);

    // If element has navigation target, navigate to target wireframe
    if (element.navigationTarget) {
      if (element.navigationTarget === '__FINISH_TEST__') { // New logic for finishing test
        completeTest();
      } else {
        setCurrentWireframeId(element.navigationTarget);
      }
    }
  };

  const handleCanvasClick = (e: React.MouseEvent) => {
    if (phase !== 'testing') return;

    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) return;

    const x = (e.clientX - rect.left) / zoom;
    const y = (e.clientY - rect.top) / zoom;

    // Record non-interactive click
    const newClick: Click = {
      x,
      y,
      wireframeId: currentWireframeId,
      timestamp: new Date().toISOString(),
      correct: false
    };

    setClicks(prev => [...prev, newClick]);
  };

  const completeTest = async () => {
    if (isDemoMode) {
      showLoading("Finalizando demonstração...");
      setTimeout(() => {
        hideLoading();
        onCancel(); // Go back without saving
      }, 500); // Short delay for user feedback
      return;
    }

    const endTime = new Date().toISOString();
    
    // Calculate test duration
    const duration = new Date(endTime).getTime() - new Date(startTime).getTime(); // in milliseconds

    // Calculate clicks per wireframe
    const clicksPerWireframe: { [wireframeId: string]: number } = {};
    clicks.forEach(click => {
      clicksPerWireframe[click.wireframeId] = (clicksPerWireframe[click.wireframeId] || 0) + 1;
    });

    // Calculate correct/incorrect clicks
    const correctClicks = clicks.filter(click => click.correct).length;
    const incorrectClicks = clicks.filter(click => !click.correct).length;

    // Calculate idle time (simplified: difference between last click and end time if no further clicks, or between clicks)
    let idleTime = 0; // in milliseconds
    if (clicks.length > 1) {
      for (let i = 1; i < clicks.length; i++) {
        idleTime += new Date(clicks[i].timestamp).getTime() - new Date(clicks[i-1].timestamp).getTime();
      }
      // Subtract total click duration from total test duration to get idle time
      idleTime = duration - idleTime; 
    } else if (clicks.length === 1) {
      idleTime = duration - (new Date(clicks[0].timestamp).getTime() - new Date(startTime).getTime());
    } else { // No clicks at all
      idleTime = duration;
    }

    // Heatmap data will be generated from the 'clicks' array on the dashboard side

    const session: TestSession = {
      id: uuidv4(),
      testId: test.id,
      userName: userName.trim(),
      userEmail: userEmail.trim(),
      clicks,
      startTime,
      endTime,
      completed: true,
      duration, // Add duration
      clicksPerWireframe, // Add clicks per wireframe
      correctClicks, // Add correct clicks
      incorrectClicks, // Add incorrect clicks
      idleTime // Add idle time
    };
    
    // The onFinishTest function is expected to handle its own loading indicators and errors.
    await onFinishTest(session);
  };

  const canvasDimensions = getCanvasDimensions();

  if (phase === 'intro') {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100">
        <Card className="w-full max-w-md">
          <CardHeader className="text-center">
            <CardTitle className="text-2xl">Teste de Usabilidade</CardTitle>
            <p className="text-muted-foreground mt-2">
              {test.name}
            </p>
            <p className="text-sm text-muted-foreground mt-1">
              Objetivo: {test.objective}
            </p>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label htmlFor="user-name">Seu nome</Label>
              <Input
                id="user-name"
                value={userName}
                onChange={(e) => setUserName(e.target.value)}
                placeholder="Digite seu nome"
              />
            </div>
            
            <div>
              <Label htmlFor="user-email">Seu e-mail</Label>
              <Input
                id="user-email"
                type="email"
                value={userEmail}
                onChange={(e) => setUserEmail(e.target.value)}
                placeholder="seu@email.com"
              />
            </div>

            <div>
              <Label htmlFor="user-phone">Seu telefone</Label>
              <Input
                id="user-phone"
                type="tel"
                value={userPhone}
                onChange={(e) => setUserPhone(e.target.value)}
                placeholder="(99) 99999-9999"
              />
            </div>

            <div className="text-sm text-muted-foreground bg-muted/50 rounded p-3">
              <h4 className="font-medium mb-2">Instruções:</h4>
              <ul className="space-y-1">
                <li>• Você verá algumas telas de wireframe</li>
                <li>• Clique nos elementos para navegar</li>
                <li>• Todos os seus cliques serão registrados</li>
                <li>• Não há respostas certas ou erradas</li>
              </ul>
            </div>

            <Button 
              onClick={handleStartTest} 
              className="w-full"
              disabled={!userName.trim() || !userEmail.trim()}
            >
              Continuar
              <ArrowRight className="w-4 h-4 ml-2" />
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (phase === 'consent') {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100">
        <Card className="w-full max-w-lg">
          <CardHeader>
            <CardTitle>Termo de Consentimento</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="text-sm space-y-3">
              <p>
                Ao participar deste teste de usabilidade, você concorda com os seguintes termos:
              </p>
              
              <ul className="space-y-2 ml-4">
                <li>• Seus cliques e interações serão registrados para fins de análise</li>
                <li>• Os dados coletados serão usados apenas para melhorar a experiência do usuário</li>
                <li>• Suas informações pessoais serão mantidas confidenciais</li>
                <li>• Você pode interromper o teste a qualquer momento</li>
                <li>• Os resultados podem ser usados em relatórios de usabilidade</li>
              </ul>
              
              <p className="text-muted-foreground">
                Este teste é apenas para fins educacionais e de pesquisa de UX.
              </p>
            </div>

            <div className="flex items-center space-x-2">
              <Checkbox 
                id="consent" 
                checked={consentAccepted}
                onCheckedChange={(checked) => setConsentAccepted(!!checked)}
              />
              <Label htmlFor="consent" className="text-sm">
                Eu li e aceito os termos de consentimento
              </Label>
            </div>

            <div className="flex gap-2">
              <Button 
                onClick={handleAcceptConsent}
                disabled={!consentAccepted}
                className="flex-1"
              >
                Iniciar teste
                <ArrowRight className="w-4 h-4 ml-2" />
              </Button>
              <Button 
                variant="outline" 
                onClick={onCancel}
              >
                Cancelar
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (phase === 'disqualified') {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-red-50 to-red-100">
        <Card className="w-full max-w-md text-center p-6">
          <CardHeader>
            <CardTitle className="text-3xl font-bold text-red-800">
              Participação Encerrada
            </CardTitle>
            <p className="text-muted-foreground mt-3 text-lg">
              Agradecemos seu interesse, mas você não atende aos critérios para este teste.
            </p>
          </CardHeader>
          <CardContent className="mt-6">
            <Button onClick={onCancel} className="w-full" size="lg">
              Sair
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }



  // Testing phase
  if (phase === 'testing' && test.type !== 'pesquisa') {
    return (
      <div className="min-h-screen flex flex-col bg-background">
        {/* Removido: O GlobalLoading cuidará disso */}
        {/* {isLoading && (
          <div className="absolute inset-0 bg-background/80 flex items-center justify-center z-50">
            <div className="flex flex-col items-center space-y-4">
              <svg className="animate-spin h-10 w-10 text-primary" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <p className="text-lg font-medium">Finalizando teste...</p>
              <p className="text-sm text-muted-foreground">Aguarde enquanto salvamos seus resultados.</p>
            </div>
          </div>
        )} */}
        {/* Simple header */}
        <div className="border-b border-border p-4 bg-card">
          <div className="text-center">
            <h3 className="text-lg">Teste de Usabilidade</h3>
            <p className="text-sm text-muted-foreground">
              Navegue pela interface clicando nos elementos • {clicks.length} cliques registrados
            </p>
          </div>
        </div>

        {/* Canvas */}
        <div className="flex-1 flex items-center justify-center p-8 bg-muted/20">
          <div
            ref={canvasRef}
            className="bg-white border-2 border-gray-300 relative shadow-lg cursor-pointer"
            style={{
              width: canvasDimensions.width * zoom,
              height: canvasDimensions.height * zoom,
            }}
            onClick={handleCanvasClick}
          >
            {/* Wireframe Elements */}
            {currentWireframe?.elements
              .slice()
              .sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0))
              .map((element) => (
              <div
                key={element.id}
                className={`absolute ${
                  element.type === 'line' ? 'border-0 border-t-2 border-gray-300' : 
                  element.type === 'text' ? 'border-0' : 'border-2 border-gray-300'
                } ${
                  element.type === 'button' ? 'bg-gray-100' : 'bg-transparent'
                } ${
                  element.type === 'circle' ? 'rounded-full' : 
                  element.type === 'button' ? 'rounded' : ''
                } flex items-center justify-center`}
                style={{
                  left: element.x * zoom,
                  top: element.y * zoom,
                  width: element.type === 'line' ? Math.abs(element.width) * zoom : element.width * zoom,
                  height: element.type === 'line' ? 0 : element.height * zoom,
                  backgroundColor: element.backgroundColor || (element.type === 'text' ? 'transparent' : '#ffffff'),
                  borderWidth: element.type === 'text' || element.type === 'line' ? undefined : `${element.borderWidth || 2}px`,
                  zIndex: element.zIndex || 0
                }}
              >
                {/* Text content */}
                {element.text && (
                  <div 
                    className={`w-full h-full flex items-center justify-center font-medium ${
                      element.navigationTarget ? 'pointer-events-none' : ''
                    }`}
                    style={{ 
                      padding: element.type === 'text' ? `${4 * zoom}px` : `${2 * zoom}px`
                    }}
                  >
                    <div
                      className="break-words hyphens-auto w-full text-center"
                      style={{ 
                        fontSize: `${getFontSize(element, project.resolution) * zoom}px`,
                        color: element.textColor || '#374151',
                        lineHeight: 1.2,
                        wordWrap: 'break-word',
                        overflowWrap: 'break-word',
                        wordBreak: 'break-word',
                        whiteSpace: 'pre-wrap'
                      }}
                    >
                      {element.text}
                    </div>
                  </div>
                )}
                
                {/* Image content */}
                {element.type === 'image' && (
                  <ImageWithFallback
                    src={element.imageSrc || imageplaceholder}
                    alt="Imagem"
                    className="w-full h-full object-cover pointer-events-none"
                    style={{
                      borderRadius: element.type === 'circle' ? '50%' : undefined
                    }}
                  />
                )}
                
                {/* Video content */}
                {element.type === 'video' && (
                  <div className="w-full h-full relative bg-gray-100 flex items-center justify-center">
                    <ImageWithFallback
                      src={element.videoSrc || videoplaceholder}
                      alt="Vídeo"
                      className="w-full h-full object-cover pointer-events-none"
                    />
                    <div className="absolute inset-0 flex items-center justify-center">
                      <div className="w-8 h-8 bg-black/60 rounded-full flex items-center justify-center">
                        <div className="w-0 h-0 border-l-4 border-t-2 border-b-2 border-l-white border-t-transparent border-b-transparent ml-1"></div>
                      </div>
                    </div>
                  </div>
                )}
                
                {/* Icon content */}
                {element.type === 'icon' && element.iconComponent && (
                  <div className="w-full h-full flex items-center justify-center">
                    <Suspense fallback={<div>...</div>}>
                      {(() => {
                        const IconComponent = iconIndex[element.iconComponent];
                        if (IconComponent) {
                          return (
                            <IconComponent
                              style={{
                                fontSize: Math.min(element.width, element.height) * zoom * 0.6,
                                color: element.textColor || 'var(--foreground)',
                                width: '100%',
                                height: '100%',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center'
                              }}
                            />
                          );
                        }
                        return <Star className="w-full h-full" style={{ color: element.textColor || 'var(--foreground)' }} />;
                      })()}
                    </Suspense>
                  </div>
                )}
                

              </div>
            ))}

            {/* Invisible clickable areas for navigation */}
            {currentWireframe?.elements
              .filter(element => element.navigationTarget)
              .map((element) => (
              <div
                key={`clickable-${element.id}`}
                className="absolute cursor-pointer"
                style={{
                  left: element.x * zoom,
                  top: element.y * zoom,
                  width: element.type === 'line' ? Math.abs(element.width) * zoom : element.width * zoom,
                  height: element.type === 'line' ? element.height * zoom : element.height * zoom,
                  zIndex: 1000 + (element.zIndex || 0),
                  backgroundColor: 'transparent'
                }}
                onClick={(e) => handleElementClick(element, e)}
              />
            ))}

            
          </div>
        </div>
      </div>
    );
  }

  return null;
}
